# The Vektor Guide ðŸ—º

Vektor's goal is to help you develop web services faster. Vektor handles much of the boilerplate needed to start building a Go server, so you can serve a request in just 10 lines of code:
```golang
import "github.com/suborbital/vektor/vk"

server := vk.New(vk.UseAppName("Vektor API Server"), vk.UseDomain("vektor.example.com"))

server.GET("/ping", HandlePing)

if err := server.Start(); err != nil {
	log.Fatal(err)
}

func HandlePing(r *http.Request, ctx *vk.Ctx) (interface{}, error) {
	return "pong", nil
}
```
But Vektor is capable of scaling up to serve powerful production workloads, using its full framework of API-oriented features.

## The server object

The `vk.Server` type contains everything needed to build a web service. It includes the router, a middleware system, customizable plug-in points, and handy built-in components like LetsEncrypt support and CORS handlers.

Creating a server object is done with `vk.New()` and accepts an optional list of `OptionModifiers` which allow customization of the server:
```golang
server := vk.New(
	vk.UseAppName("Vektor API Server"),
	vk.UseDomain("vektor.example.com"),
)
```
The included `OptionsModifiers` are:

Option | Description
--- | ---
UseDomain(domain string) | Enable LetsEncrypt support with the provided domain name (will serve on :80 and :443 for challenge server and API server). LetsEncrypt is disabled by default.
UseInsecureHTTP(port int) | Choose the port on which to serve requests. Default is port 80.
UseInsecureHTTPWithEnvPort(envKey string) | Serve requests on the port set in the `envKey` environment variable.
UseLogger(logger vlog.Logger) | Set the logger object to be used, which conforms to the `vlog.Logger` interface. The logger is used internally by `vk` and is available to all handler functions via the `ctx` object. `vlog.DefaultLogger` is used by default.
UseAppName(name string) | When the application starts, `name` will be logged. Empty by default.

## Handler functions

`vk`'s handler function definition is:
```golang
func HandlePing(r *http.Request, ctx *vk.Ctx) (interface{}, error)
```
Here's a breakdown of each part:

`r *http.Request`: The request object for the request being handled.

`ctx *vk.Ctx`: A context object containing more options for interacting with the request. Ctx includes a standard Go `context.Context` which can be augmented with any value, a `vlog.Logger` object for logging within request handlers, and an `httprouter.Params` object to access URL parameters (such as `/users/:uuid`).

`(interface{}, error)`: The return types of the handler allow you to respond to HTTP requests by simply returning values. If an error is returned, `vk` will interpret it as a failed request and respond with an error code, if error is `nil`, then the first value is used to respond based on the response handling rules (see below).

## Response types

`vk` includes two types, `Response` and `Error` (with helper functions `vk.Respond` and `vk.Error`) that can be used to gain extra control over the response code and contents that you want to return:

```golang
type createdResponse struct {
	Name string `json:"name"`
	UUID string `json:"uuid"`
}

func HandleCreate(r *http.Request, ctx *vk.Ctx) (interface{}, error) {
	// Do some work

	resp := createdResponse {
		Name: "Wendy",
		UUID: "jfioqerjhp98qergnjw98h23"
	}

	// Return 201 (Created) and JSON
	return vk.Respond(http.StatusCreated, resp), nil
}

func HandleDelete(r *http.Request, ctx *vk.Ctx) (interface{}, error) {
	// Oops, something went wrong

	return nil, vk.Error(http.StatusConflict, "the user is already deleted") // responds with HTTP status 409 and body {"status": 409, "message": "the user is already deleted"}
}
```
`vk.Respond` and `vk.Error` can be used with their shortcuts `vk.R` and `vk.E` if you like your code to be terse.

## Response handling rules

`vk` processes the `(interface{}, error)` returned by handler functions in a spcific way to ensure you always know how it will behave while still being able to use simple types in your code.

**The rules for successful responses (i.e. the `interface{}` returned by handler functions) are as follows:**

1. If the type is `vk.Response`, set the HTTP response code provided and process `Response.body` as follows. (If the type is NOT `vk.Response`, the status code is set to `200 OK`)
1. If the type is string, write the string (as UTF-8 bytes) to the response body.
1. If the type is bytes, write them directly to the response body.
1. If the type is a struct, attempt to marshal to JSON and write JSON bytes to the response body.

Examples:

Handler returns... | Status Code | Response body
--- | --- | ---
`return "Hello, World", nil` | 200 OK | "Hello World" (as UTF-8 bytes)
`return jsonBytesFromJSONMarshal, nil` | 200 OK | [JSON bytes as generated by json.Marshal]
`return someStructInstance, nil` | 200 OK | [JSON respresentation of struct automatically marshalled by `vk`]
`return vk.R(http.StatusCreated, "created"), nil` | 201 Created | "created" (as UTF-8 bytes)
`return vk.R(http.StatusCreated, someStructInstance), nil` | 201 Created | [JSON respresentation of struct automatically marshalled by `vk`]

**The rules for failure responses (i.e. the `error` returned by handler functions) are as follows:**

1. If the type is `vk.Error`, set the HTTP response code provided and respond with JSON as follows: `{"status": $code, "message": $message}
2. If the type is NOT `vk.Error`, set the HTTP status code to 500 and write `err.Error()` as UTF-8 bytes to the response body

Examples:

Handler returns... | Status Code | Response body
--- | --- | ---
`return nil, errors.New("failed to add user")` | 500 Internal Server Error | "failed to add user" (as UTF-8 bytes)
`retuen nil, vk.E(http.StatusForbidden, "not permitted to do this thing")` | 403 Forbidden | `{status: 403, message: "not permitted to do this thing"}`